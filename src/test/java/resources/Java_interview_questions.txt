<q>
What’s the difference between String, StringBuffer andStringBuilder?
</q>

<a>
String is an immutable class. In older JDK’s the recommendation when programmatically building a String was to use StringBuffer since this was optimized to concatenate multiple Strings together. However, the methods on StringBuffer were marked as sychronized, which meant that there was a performance penalty, hence StringBuilder was introduced to provide a non-synchronized way to efficiently concatenate and modify Strings.
</a>

<q>
How do you run a Java application on the command line and set the classpath with multiple jars?
</q>

<a>
java -cp /dev/myapp.jar:/dev/mydependency.jar com.codementor.MyApp
</a>

<q>
What is the difference between final, finalize and finally?
</q>

<a>
final is a Java keyword used to indicate that either a method can not override in a subclass, or a class can not be extended or a field can not be modified. finalize is a method that gets called on an instance of an Object when it is garbage collected. finally is a Java keyword used in exception handling to indicate a block of code that should always be run whether an exception is thrown or not.
</a>

<q>
How does Garbage Collection prevent a Java application from going out of memory?
</q>

<a>
it doesn’t! Garbage Collection simply cleans up unused memory when an object goes out of scope and is no longer needed. However an application could create a huge number of large objects that causes an OutOfMemoryError.
</a>

<q>
What’s the difference between a ClassNotFoundException and NoClassDefFoundError?
</q>

<a>
A ClassNotFoundException means the class file for a requested class is not on the classpath of the application. A NoClassDefFoundErrormeans that the class file existed at runtime, but for some reason the class could not be turned into a Class definition. A common cause is an exception being thrown in static initialization blocks.
</a>





<q>
Why isn’t String‘s .length() accurate?
</q>

<a>
It isn’t accurate because it will only account for the number of characters within the String. In other words, it will fail to account for code points outside of what is called the BMP (Basic Multilingual Plane), that is, code points with a value of U+10000 or greater.
The reason is historical: when Java was first defined, one of its goal was to treat all text as Unicode; but at this time, Unicode did not define code points outside of the BMP. By the time Unicode defined such code points, it was too late for char to be changed.
This means that code points outside the BMP are represented with two chars in Java, in what is called a surrogate pair. Technically, a char in Java is a UTF-16 code unit.
The correct way to count the real numbers of characters within a String, i.e. the number of code points, is either:
someString.codePointCount(0, someString.length())
or, with Java 8:
someString.codePoints().count()
</a>

<q>
Given two double values d1, d2, why isn’t it reliable to test their equality using:

d1 == d2
</q>

<a>

Because of Double.NaN (literally: “Not a Number”).
This code:
final double d1 = Double.NaN;
final double d2 = Double.NaN;

System.out.println(d1 == d2);
will print false.
The most accurate way to tell whether two double values are equal to one another is to use Double.compare() and test against 0, as in:
System.out.println(Double.compare(d1, d2) == 0);
</a>

<q>
What is the problem with this code:

final byte[] bytes = someString.getBytes();

</q>

<a>
There are, in fact, two problems:
•	the code relies on the default Charset of the JVM;
•	it supposes that this default Charset can handle all characters.
While the second problem is rarely a concern, the first certainly is a concern.
For instance, in most Windows installations, the default charset is CP1252; but on Linux installations, the default charset will be UTF-8.
As such, such a simple string as “é” will give a different result for this operation depending on whether this code is run on Windows or Linux.
The solution is to always specify a Charset, as in, for instance:
final byte[] bytes = someString.getBytes(StandardCharsets.UTF_8);
</a>

<q>
What is the JIT?
</q>

<a>
The JIT is the JVM’s mechanism by which it can optimize code at runtime.
JIT means Just In Time. It is a central feature of any JVM. Among other optimizations, it can perform code inlining, lock coarsening or lock eliding, escape analysis etc.
The main benefit of the JIT is on the programmer’s side: code should be written so that it just works; if the code can be optimized at runtime, more often than not, the JIT will find a way.
(On a more advanced note: the JIT is such a complex piece of machinery that it makes it complicated to do accurate performance benchmarks for JVM code; this is why such frameworks as JMH exist.)
</a>


<q>
This code:
final double d = 1 / 2;

System.out.println(d);
prints 0. Why? How do you make this code print 0.5 instead?
</q>

<a>
The problem here is that this expression:
1 / 2
has integer literals on both sides of the operator: 1 and 2. As a consequence, an integer division will be performed, and the result of 1 divided by 2 in an integer division is 0.
In order for the result to be a double as expected, at least one operand of the operation needs to be a double. For instance:
final double d = 1 / 2.0;
or:
final double d = 1.0 / 2;
</a>


<q>
In this code

IntStream.range(0, 10).forEach(System.out::println);

what is the inferred type of the method reference used in

System.out::println?
</q>

<a>
It is an IntConsumer.
IntStream.range(0, 10) returns an IntStream, and IntStream defines a .forEach() method accepting an IntConsumer as an argument, whose prototype is:
void accept(int value);
System.out is a PrintStream, and a PrintStream has a method named println which takes an int as an argument and returns void. This matches the signature of an IntConsumer, hence the result.
</a>

<q>
What is the problem with this code

final Path path = Paths.get(...);

Files.lines(path).forEach(System.out::println);
</q>

<a>
The problem is that the Stream returned by Files.lines() is not closed.
This should be used instead:
try (
    final Stream<String> stream = Files.lines(path);
) {
    stream.forEach(System.out::println);
}
Stream extends BaseStream, and BaseStream extends AutoCloseable. While this has no influence on streams you obtain from collections for instance, the stream returned by Files.lines() is I/O bound. Neglecting to close it correctly may lead to a resource leak in the event of an error occurring while processing the stream.
</a>


<q>
Consider the following piece of code:

final List<Integer> list = new ArrayList<>();

list.add(1);
list.add(2);
list.add(3);

list.remove(2);
What will be the contents of the list after this operation and why?
</q>

<a>
The contents will be:
[ 1, 2 ]
The reason is that there are two removal operations on a List:
•	remove(int index)
•	remove(Object obj)
The JVM will always select the most specific overload of a method; and here we pass an int as an argument, the code therefore removes the element at index 2.
To remove the _element_ 2 from the list, the following needs to be written:
list.remove(Integer.valueOf(2));
</a>




<q>
Write a function to detect if two strings are anagrams (for example, SAVE and VASE)
</q>

<a>
The details of the implementation are not important; what’s important is someone understanding what they need to do, and then understanding why their solution works or doesn’t work. If you can demonstrate this, you’re on the right track.
Here is one way to implement a better solution, comparing sorted strings:
public static boolean isAcronymMoreBetter(String s1, String s2) {
    char[] s1Chars = s1.toCharArray();
    char[] s2Chars = s2.toCharArray();
    Arrays.sort(s1Chars);
    Arrays.sort(s2Chars);
    return Arrays.equals(s1Chars, s2Chars);
}
</a>





<q>
What is the contract between equals and hashCode of an object?
</q>

<a>
The only obligation is that for any objects o1 and o2 then if o1.equals(o2) is true then o1.hashCode() == o2.hashCode() is true.
Note that this relationship goes only one way: for any o1, o2 of some class C, where none of o1 and o2 are null, then it can happen that o1.hashCode() == o2.hashCode() is true BUT o1.equals(o2) is false.
</a>


<q>
Can an enum be extended?
</q>

<a>
No. Enum types are final by design.
</a>


<q>
How threadsafe is enum in Java?
</q>

<a>
Creation of an enum is guaranteed to be threadsafe. However, the methods on an enum type are not necessarily threadsafe
</a>


<q>
How does the JVM handle storing local variables vs storing objects?
</q>

<a>
Objects are stored on the heap. Variables are a reference to the object.
Local variables are stored on the stack.
</a>


<q>
Identify the problem in the below code:

public class Foo {
    public Foo() {
        doSomething();
    }

    public void doSomething() {
        System.out.println("do something acceptable");
    }
}

public class Bar extends Foo {
    public void doSomething() {
        System.out.println("yolo");
        Zoom zoom = new Zoom(this);
    }
}
</q>

<a>
Classic example for escaping references.
When an object of Bar is created, the super constructor in Foo gets called first, which in turn calls the ‘overridden’ doSomething method.
The doSomething method passes the this instance to the class Zoom. Zoom now can use the ‘this‘ instance before it is created entirely. BAD!!!
</a>




<q>
When do you use volatile variables?
</q>

<a>
When a member variable is accessed by multiple threads and want the value of a volatile field to be visible to all readers (other threads in particular) after a write operation completes on it.
</a>


<q>
Why do you need to use synchronized methods or blocks?
</q>

<a>
If threads are being used and a number of threads have to go through a synchronized section of code, only one of them may be executed at a time. This is used to make sure shared variables are not updated by multiple threads.
</a>


<q>
What is the difference between HashMap and ConcurrentHashMap?
</q>

<a>
ConcurrentHashMap is thread-safe; that is the code can be accessed by single thread at a time while HashMap is not thread-safe. ConcurrentHashMap does not allow NULL keys while HashMap allows it.
</a>


<q>
When do you need to override the equals and hashCode methods in Java?
</q>

<a>
By defining equals() and hashCode() consistently, the candidate can improve the usability of classes as keys in hash-based collections such as HashMap.
</a>


<q>
What is a Service?
</q>

<a>
A service is a function that is well-defined, self-contained, and does not depend on the context or state of other services.
</a>


<q>
What is a good usecase of calling System.gc()?
</q>

<a>
One may call System.gc() when profiling an application to search for possible memory leaks. All the profilers call this method just before taking a memory snapshot.
</a>


<q>
What is the marker interface in Java?
</q>

<a>
The marker interface in Java is an interfaces with no field or methods. In other words, it an empty interface in java is called a marker interface. An example of a marker interface is a Serializable, Clonable and Remote interface. These are used to indicate something to the compiler or JVM.
</a>

<q>
How are Annotations better than a Marker Interfaces?
</q>

<a>
Annotations lets one achieve the same purpose of conveying metadata about the class to its consumers without creating a separate type for it. Annotations are more powerful, too, letting programmers pass more sophisticated information to classes that “consume” it.
</a>


<q>
What are checked and unchecked exceptions? When do you use them?
</q>

<a>
A checked exception is an exception that must be catch, they are checked by the compiler. An unchecked exception is mostly runtime exception, and is not required to be catch. In general, use checked exception when the situation is recoverable (retry, display reasonable error message).
</a>




<q>
int a = 1L; won’t compile and int b = 0; b += 1L; compiles fine. Why ?
</q>

<a>
When += is used, that’s a compound statement and the compiler internally casts it. Whereas in the first case, the compiler straightaway shouts at you since it is a direct statement.
Compiler behavior and statement types can be confusing, so questions like this will test a candidate's grasp of these concepts.
</a>



<q>
Why aren’t you allowed to extend more than one class in Java but are allowed to implement multiple interfaces?
</q>

<a>
I really don't like the term "inherit" here, it leads to a lot of confusion. Java only allows interfaces to extend other interfaces, and for classes to implement interfaces.
If you look at an interface as a mathematical set of declarations, then each "extends" merely provides the union of the set from the superinterface and that of the current interface. You are therefore allowed to do multiple "unions".
When you eventually get to a class that implements one or more interfaces, the semantics here are merely that the class must provide implementations for all the methods in the set. A class implementing multiple interfaces could be rewritten as a class implementing a single interface that extends all the above interfaces.
In the case of classes inheriting multiple classes it is not allowed because it leads to a variety of problems, including the diamond problem. For instance, if I have two supertypes with different implementations of the same method signature, which one should be used in the subtype?
</a>



<q>
Why doesn’t the following code generate a NullPointerException even when the instance is null?
</q>

<a>
Test t = null;
t.someMethod();


 public static void someMethod() {
  ...
}
There is no need for an instance while invoking a static member or method, since static members belongs to a class rather than an instance.
A null reference may be used to access a class (static) variable without causing an exception.
</a>



<q>
When dealing with the Integer clas and not int. Why does the following output false and true
public class Test
{
    public static void main(String[] args)
    {
        Integer a = 1000, b = 1000;
        System.out.println(a == b);

        Integer c = 100, d = 100;
        System.out.println(c == d);
    }
}
outputs:
false
true
</q>

<a>
JVM’s cache behavior can be confusing, so this question tests that concept. The second output is true as we are comparing the references, because the JVM tries to save memory when the Integer falls within a range (from -128 to 127). At point 2, no new reference of type Integer is created for ‘d’. Instead of creating a new object for the Integer type reference variable ‘d’, it is only assigned with a previously created object referenced by ‘c’. All of these are done by JVM.
</a>



<q>
Give real world examples of when to use an ArrayList and when to use LinkedList.
</q>

<a>
ArrayList is preferred when there are more get(int), or when search operations need to be performed as every search operation runtime is O(1).
If an application requires more insert(int) and delete(int) operations, then LinkedList is preferred, as LinkedList does not need to maintain back and forth to preserve continued indices as arraylist does. Overall this question tests the proper usage of collections.
</a>


<q>
What is the difference between an Iterator and a ListIterator ?
</q>

<a>
This question tests the proper usage of collection iterators. One can only use ListIterator to traverse Lists, and cannot traverse a Set using ListIterator.
What’s more, one can only traverse in a forward direction using Iterators. Using ListIterator, one can traverse a List in both the directions (forward and backward).
One cannot obtain indexes while using Iterator. Indexes can be obtained at any point of time while traversing a list using ListIterator. The methods nextIndex() and previousIndex() are used for this purpose.
</a>



<q>
What is the advantage of generic collection?
</q>

<a>
They enable stronger type checks at compile time.
A Java compiler applies strong type checking to generic code, and issues errors if the code violates type safety. Fixing compile-time errors is easier than fixing runtime errors, which can be difficult to find.
</a>

